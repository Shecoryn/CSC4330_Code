import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.BufferedReader;
public class Test2_Problem4 {
	final static int LETTER = 0;
	final static int DIGIT = 1;
	final static int UNKNOWN = 99;
	final static int INT_LIT = 10;
	final static int IDENT = 11;
	final int ASSIGN_OP = 20;
	final static int ADD_OP = 21;
	final static int SUB_OP = 22;
	final static int MULT_OP = 23;
	final static int DIV_OP = 24;
	final static int LEFT_PAREN = 25;
	final static int RIGHT_PAREN = 26;
	public static final InputStreamReader br = null;
	public static void main(String[] args) throws FileNotFoundException {
		FileReader fr=new FileReader(in_fp);
	    BufferedReader br=new BufferedReader(fr);

	}
	static int charClass;
	static char lexeme[];
	static char nextChar;
	static int lexLen;
	static int token;
	static int nextToken;
	static File in_fp;

    static int c = 0;             
	public static int lookup(char ch) {
		 switch (ch) {
			 case '(':
				 addChar();
				 nextToken = LEFT_PAREN;
				 break;
			 case ')':
				 addChar();
				 nextToken = RIGHT_PAREN;
				 break;
			 case '+':
				 addChar();
				 nextToken = ADD_OP;
				 break;
			 case '-':
				 addChar();
				 nextToken = SUB_OP;
				 break;
			 case '*':
				 addChar();
				 nextToken = MULT_OP;
				 break;
			 case '/':
				 addChar();
				 nextToken = DIV_OP;
				 break;
			 default:
				 addChar();
				 nextToken = (Integer) null;
				 break;
		 }
		 return nextToken;
	}

	/******************************************************/
	/* addChar - a function to add nextChar to lexeme */
	void expr() {
		 System.out.println("Enter <expr>");
		/* Parse the first term */
		 term();
		/* As long as the next token is + or -, get
		 the next token and parse the next term */
		 while (nextToken == ADD_OP || nextToken == SUB_OP) {
			 lex();
			 term();
		 }
		 System.out.println("Exit <expr>");
	}

	/* term
	 Parses strings in the language generated by the rule:
	 <term> -> <factor> {(* | /) <factor>}
	 */
	void term() {
		System.out.println("Enter <term>");
		/* Parse the first factor */
		 factor();
		/* As long as the next token is * or /, get the
		 next token and parse the next factor */
		 while (nextToken == MULT_OP || nextToken == DIV_OP) {
			 lex();
			 factor();
		 }
		 System.out.println("Exit <term>");
	}

	/* factor
	 Parses strings in the language generated by the rule:
	 <factor> -> id | int_constant | ( <expr> )
	 */
	void factor() {
		 System.out.println("Enter <factor>");
		/* Determine which RHS */
		 if (nextToken == IDENT || nextToken == INT_LIT)
			/* Get the next token */
			 lex();
			/* If the RHS is ( <expr> ), call lex to pass over the
			 left parenthesis, call expr, and check for the right
			 parenthesis */
		 else { if (nextToken == LEFT_PAREN) {
			 lex();
			 expr();
			 if (nextToken == RIGHT_PAREN)
			 	lex();
			 else
			 	error();
			 }
			/* It was not an id, an integer literal, or a left
			 parenthesis */
			 else
			 error();
		 }
		 System.out.println("Exit <factor>");
	}
	public void error() {
		System.out.println("You done messed up");		
	}

	public static void addChar() {
		if (lexLen <= 98) {
			lexeme[lexLen++] = nextChar;
			lexeme[lexLen] = '\0';
		} else
		System.out.println("Error - lexeme is too long");
	}


	/******************************************************/
	/* getChar - a function to get the next character of
	 input and determine its character class */
	public static void getChar() {
		 try {
			if ((c = br.read()) != -1) {
				 if (isalpha(nextChar))
				 	charClass = LETTER;
				 else if (isdigit(nextChar))
				 	charClass = DIGIT;
				 else
				 	charClass = UNKNOWN;
			 } else
			 	charClass = -1;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


	private static boolean isdigit(char digit) {
		// TODO Auto-generated method stub
		return false;
	}

	private static boolean isalpha(char alpha) {
	
		return false;
	}

	/******************************************************/
	/* getNonBlank - a function to call getChar until it
	 returns a non-whitespace character */
	public static void getNonBlank() {
		while (isspace(nextChar))
		getChar();
	}

	private static boolean isspace(char nextChar2) {
		// TODO Auto-generated method stub
		return false;
	}

	/******************************************************/
	/* lex - a simple lexical analyzer for arithmetic
	 expressions */
	public static int lex() {
		 lexLen = 0;
		 getNonBlank();
		 switch (charClass) {
			/* Identifiers */
			 case LETTER:
				 addChar();
				 getChar();
				 while (charClass == LETTER || charClass == DIGIT) {
					 addChar();
					 getChar();
				 }
				 nextToken = IDENT;
				 break;
			/* Integer literals */
			 case DIGIT:
				 addChar();
				 getChar();
				 while (charClass == DIGIT) {
					 addChar();
					 getChar();
				 }
				 nextToken = INT_LIT;
			 	break;
			/* Parentheses and operators */
			 case UNKNOWN:
				 lookup(nextChar);
				 getChar();
				 break;
				/* EOF */
			case -1:
				 nextToken = -1;
				 lexeme[0] = 'E';
				 lexeme[1] = 'O';
				 lexeme[2] = 'F';
				 lexeme[3] = '\0';
			 	break;
		 } /* End of switch */
		 System.out.println("Next token is: " + nextToken + ", Next lexeme is " + lexeme);
		 return nextToken;
	} /* End of function lex */

}
